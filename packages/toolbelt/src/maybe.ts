import Maybe, { just, nothing, match } from '@true-myth/maybe';
import Result from '@true-myth/result';
import { curry1 } from '@true-myth/utils';

/**
  Transform the {@linkcode Maybe} into a {@linkcode Result.Result Result}, using
  the wrapped value as the {@linkcode Result.Ok Ok} value if {@linkcode Just};
  otherwise using the supplied `error` value for {@linkcode Result.Err Err}.

  @typeparam T  The wrapped value.
  @typeparam E  The error type to in the `Result`.
  @param error The error value to use if the `Maybe` is `Nothing`.
  @param maybe The `Maybe` instance to convert.
  @returns     A `Result` containing the value wrapped in `maybe` in an `Ok`, or
               `error` in an `Err`.
 */
export function toOkOrErr<T, E>(error: E, maybe: Maybe<T>): Result<T, E>;
export function toOkOrErr<T, E>(error: E): (maybe: Maybe<T>) => Result<T, E>;
export function toOkOrErr<T, E>(
  error: E,
  maybe?: Maybe<T>
): Result<T, E> | ((maybe: Maybe<T>) => Result<T, E>) {
  const op = (m: Maybe<T>) => (m.isJust ? Result.ok<T, E>(m.value) : Result.err<T, E>(error));
  return maybe !== undefined ? op(maybe) : op;
}

/**
                 Transform the {@linkcode Maybe} into a {@linkcode Result.Result Result}, using
                 the wrapped value as the {@linkcode Result.Ok Ok} value if {@linkcode Just};
                 otherwise using `elseFn` to generate {@linkcode Result.Err Err}.
               
                 @typeparam T  The wrapped value.
                 @typeparam E  The error type to in the `Result`.
                 @param elseFn The function which generates an error of type `E`.
                 @param maybe  The `Maybe` instance to convert.
                 @returns     A `Result` containing the value wrapped in `maybe` in an `Ok`, or
                              the value generated by `elseFn` in an `Err`.
                */
export function toOkOrElseErr<T, E>(elseFn: () => E, maybe: Maybe<T>): Result<T, E>;
export function toOkOrElseErr<T, E>(elseFn: () => E): (maybe: Maybe<T>) => Result<T, E>;
export function toOkOrElseErr<T, E>(
  elseFn: () => E,
  maybe?: Maybe<T>
): Result<T, E> | ((maybe: Maybe<T>) => Result<T, E>) {
  const op = (m: Maybe<T>) => (m.isJust ? Result.ok<T, E>(m.value) : Result.err<T, E>(elseFn()));
  return curry1(op, maybe);
}

/**
  Construct a {@linkcode Maybe Maybe<T>} from a
  {@linkcode Result.Result Result<T, E>}.

  If the `Result` is an {@linkcode Result.Ok Ok}, wrap its value in
  {@linkcode Just}. If the `Result` is an {@linkcode Result.Err Err}, throw away
  the wrapped `E` and transform to a {@linkcode Nothing}.

  @typeparam T  The type of the value wrapped in a `Result.Ok` and in the `Just`
                of the resulting `Maybe`.
  @param result The `Result` to construct a `Maybe` from.
  @returns      `Just` if `result` was `Ok` or `Nothing` if it was `Err`.
  */
export function fromResult<T>(result: Result<T, unknown>): Maybe<T> {
  return result.isOk ? just(result.value) : nothing();
}

/**
  Transposes a {@linkcode Result.Result Result} of a {@linkcode Maybe} into a
  `Maybe` of a `Result`.

  | Input         | Output         |
  | ------------- | -------------- |
  | `Ok(Just(T))` | `Just(Ok(T))`  |
  | `Err(E)`      | `Just(Err(E))` |
  | `Ok(Nothing)` | `Nothing`      |

  @param result a `Result<Maybe<T>, E>` to transform to a `Maybe<Result<T, E>>`.
 */
export function transposeResult<T, E>(result: Result<Maybe<T>, E>): Maybe<Result<T, E>> {
  return result.match({
    Ok: match({
      Just: v => just(Result.ok<T, E>(v)),
      Nothing: () => nothing<Result<T, E>>(),
    }),
    Err: e => Maybe.just(Result.err<T, E>(e)),
  });
}
